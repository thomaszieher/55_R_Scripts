---
title: "Irrigation monitoring"
author: "Thomas"
date: "21. March 2016"
output: html_document
---

###Import and interpolate data
```{r echo=F,message=F,warning=F,include=F}
require(spgrass6)
require(rgdal)
require(foreign)
require(raster)
require(RColorBrewer)
require(qpcR)
require(lattice)
require(pracma)

##set parent directory
#rootPath=dirname(getwd())
#rootPath="C:\\PHD\\Code_Projects\\55_check_ert"
rootPath="F:\\55_check_ert""
grassPath=paste(rootPath,"01_DATA","grass",sep="\\")
TDRPath=paste(rootPath,"01_DATA","53_tdr",sep="\\")
SWCCPath=paste(rootPath,"01_DATA","08_vanGenuchten\\curve_fitting",sep="\\")
TRIGRSPath=paste(rootPath,"01_DATA","10_trigrs_singlecell\\data",sep="\\")

setwd(rootPath)

##############################################################################
##settings
##############################################################################
location="Laterns"
mapset="ERT_monbonacker"
##specify irrigation plot measures
maximum.depth=20
plot.min=31
plot.max=196
##############################################################################


##FUNCTIONS
roundUp=function(x,to){
  to*(x%/%to+as.logical(x%%to))
}

roundDown=function(x,to){
  to*(x%/%to)
}

getDiff=function(rastT1,rastT2){
  diff=rastT1
  diff@data@values=rastT2@data@values-rastT1@data@values
  return(diff)
}

getRatio=function(rastT1,rastT2){
  ratio=rastT1
  ratio@data@values=rastT2@data@values/rastT1@data@values
  return(ratio)
}

as.Raster=function(rast){
  ##convert spatial data frame to raster
  ncols=rast@grid@cells.dim[1]
  nrows=rast@grid@cells.dim[2]
  offsetX=rast@grid@cellcentre.offset[1]
  offsetY=rast@grid@cellcentre.offset[2]
  proj4=rast@proj4string
  ##create coordinates for new raster
  xCor=((rep(seq(1,ncols,by=1),times=nrows)-1)*cellsize)-offsetX
  yCor=(((rep(1:nrows,each=ncols)-1)*-1)*cellsize)-offsetY
  ##fill data frame
  df=data.frame(x=xCor,
                y=yCor,
                data=rast@data
  )
  ##set coordinates
  coordinates(df)=~x+y
  ##grid it
  gridded(df)=T
  ##convert data frame to raster
  converted=raster(df)
  ##set projection
  crs(converted)=proj4
  return(converted)
}


##set GRASS environment
initGRASS(gisBase="C:\\QGIS\\apps\\grass\\grass-6.4.3",
          home=tempdir(),
          gisDbase=grassPath,
          location=location,
          mapset=mapset,
          override=T)

##get list of raster data sets
rlist=execGRASS("g.mlist",parameters=list(type="rast",pattern="ert_*"),intern=T)
timelist=data.frame(measurements=rlist)
timelist["time"]=sprintf("%s:%s",substr(timelist$measurements,5,6),substr(timelist$measurements,8,9))

##set colors
colorsERT=colorRampPalette(rev(brewer.pal(9,"PuBu")))(90)
##add white
colorsERT=c(colorsERT,c("#FFFFFF"))
colors=rev(colorRampPalette(brewer.pal(9,"RdBu"))(100))
#colors=rev(colorRampPalette(brewer.pal(9,"Spectral"))(10))

##read first raster
rast0=readRAST6(rlist[2])
par(las=1,xaxs="i",yaxs="i",cex=1.2)
#hist(rast0@data[,1],breaks=100,xlab="Resistivity [Ohm m]")
##get nrows, ncols and cellsize of spatial data frame
ncols=rast0@grid@cells.dim[1]
nrows=rast0@grid@cells.dim[2]
cellsize=rast0@grid@cellsize[1]

##convert to raster (format of raster package)
rast0=as.Raster(rast0)

##import position of ERT probes
probesERT=readVECT6("sond_pos")

##import irrigation plot
irr_plot=readVECT6("irrig_plot")

##import ert mask
irr_mask=readVECT6("mask")

##import irrigation plot border
irr_border=readVECT6("border_irrplot")

##import dcpt data
dcpt.vect=readVECT6(vname="dcpt_points")
##calculate resistivity
##blow calculation (sonding settings)
m=10.0 #[kg]
A=5.0/10000.0 #[m2]
g=9.80665 #[m/s2]
h=0.50 #[m]
dcpt.vect@data["energy"]=dcpt.vect@data*m*h*g/A/1000.0

##build depth mask
depth.mask=(as.matrix(rast0))
dcpt.mask=(as.matrix(rast0))
length.mask=(as.matrix(rast0))

##summarize pixel cellsize in y-direction (depth-array)
##and create DCPT-depth mask
depthMax=0
count=1
for (col in seq(1,ncols,by=1)){
  depth=cellsize
  #count=1
  for (row in seq(1,nrows,by=1)){
    if (!is.nan(depth.mask[row,col])){
      depth.mask[row,col]=round(depth,2)
      dcpt.mask[row,col]=count
      length.mask[row,col]=col
      if (round(depth,2)%%1==0){
        count=count+1
      }
      if (depth>depthMax){
        depthMax=depth
      }
      depth=depth+cellsize
    }
  }
  count=count+1
}
```


Import raster and vector data from GRASS GIS location  
Inversion models interpolated with optimized (cross-validated) regularized spline with tension (RST)
```{r echo=F,message=F,warning=F}
##show first ert
par(mfrow=c(1,1),mar=c(4,5,4,6),xaxs="i",yaxs="i")
plot(NA,NA,xlim=c(0,250),ylim=c(-150,0),axes=F,xlab="",ylab="",asp=1)
axis(side=1,at=seq(0,250,by=50),labels=seq(0,250,by=50)/10)
mtext(side=1,line=2.5,"Relative distance [m]")
axis(side=2,at=seq(-150,0,by=50),labels=seq(0,150,by=50)/10,las=1)
mtext(side=2,line=2.5,"Relative elevation [m]",las=0)
mtext(side=4,"Resistivity [Ohm m]",las=0,line=4.5)
plot(rast0,add=T,axes=F,box=F)#,zlim=c(0,1300))
#plot(irr_plot,add=T)
points(probesERT,pch=3,cex=0.5)
#points(dcpt.vect$coords.x1,dcpt.vect$coords.x2,cex=0.2)
```



###Value range of first five datasets
First five measurements conducted before the beginning of irrigation experiment  
Range assumed to represent the repeatability and uncertainties of the measurements  
Generally higher uncertainties near the surface
```{r echo=F,message=F,warning=F}
##measurement uncertainties of material properties before irrigation (value range)
#execGRASS("r.series",input=rlist[2:6],output="before_range",method="range",flag="overwrite")
rangeERT=as.Raster(readRAST6("before_range"))
##boxplot
#boxplot(rangeERT@data@values)
##ecdf
#plot(ecdf(rangeERT@data@values))
#abline(v=c(mean(rangeERT@data@values,na.rm=T)),lty=2,col="red",lwd=2)
#hist(rangeERT@data@values,breaks=100)
par(mfrow=c(1,1),mar=c(5,5,5,5),xaxs="i",yaxs="i")
plot(NA,NA,xlim=c(0,250),ylim=c(-150,0),axes=F,xlab="",ylab="",asp=1)
axis(side=1,at=seq(0,250,by=50),labels=seq(0,250,by=50)/10)
mtext(side=1,line=2.5,"Relative distance [m]")
axis(side=2,at=seq(-150,0,by=50),labels=seq(0,150,by=50)/10,las=1)
mtext(side=2,line=2.5,"Relative elevation [m]",las=0)
mtext(side=4,"Range [Ohm m]",las=0,line=3.5)
plot(rangeERT,add=T,axes=F,box=F)


##material properties before irrigation (mean value)
#execGRASS("r.series",input=rlist[2:6],output="before_mean",method="average",flag="overwrite")
material.before=as.Raster(readRAST6("before_mean"))
##boxplot
#boxplot(material.before@data@values)
##ecdf
#plot(ecdf(material.before@data@values))
#mean(material.before@data@values,na.rm=T)
#abline(v=c(mean(material.before@data@values,na.rm=T)),lty=2,col="red",lwd=2)
#hist(material.before@data@values,breaks=100)
#plot(material.before,main="")
#points(dcpt.vect,pch=20,cex=0.5)
#points(probesERT,pch=3,cex=0.5)
```


Relative deviation from mean  
```{r echo=F,message=F,warning=F}
##plot spatial uncertainties
par(mfrow=c(1,1),mar=c(5,5,5,5),oma=c(0,0,0,0),xaxs="i",yaxs="i")
plot(NA,NA,xlim=c(0,250),ylim=c(-150,0),axes=F,xlab="",ylab="",asp=1)
axis(side=1,at=seq(0,250,by=50),labels=seq(0,250,by=50)/10)
mtext(side=1,line=2.5,"Relative distance [m]")
axis(side=2,at=seq(-150,0,by=50),labels=seq(0,150,by=50)/10,las=1)
mtext(side=2,line=2.5,"Relative elevation [m]",las=0)
mtext(side=4,"Relative deviation [%]",las=0,line=3)
plot((rangeERT/material.before)*100,axes=F,box=F,add=T,asp=1,zlim=c(0,4.5))
```


Mean deviation with depth (relative to mean of first five measurements)  
```{r echo=F,message=F,warning=F}
##relative proportion of range for differences
start=2
end=6
xMin=-0.5
xMax=0.5
cols.uncert=data.frame(run=start:end,col=colorRampPalette(rev(brewer.pal(5,"Set2")))(end-start+1),stringsAsFactors=F)
##plot
par(mfrow=c(1,1),xaxs="i",yaxs="i")
plot(NA,NA,type="l",col="red",ylim=c(47,0),xlim=c(xMin,xMax),axes=F,xlab="",ylab="")
axis(side=1,at=seq(xMin,xMax,by=0.25))
mtext(side=1,"Mean deviation [%]",line=2.5)
axis(side=2,at=seq(0,50,by=10),labels=seq(0,50,by=10)/10,las=1)
mtext(side=2,"Depth [m]",line=2.5,las=0)
abline(v=seq(xMin+1,xMax,by=1),lty=2,lwd=0.2,col="gray70")
abline(h=seq(5,50,by=5),lty=2,lwd=0.2,col="gray70")
for (i in seq(start,end,by=1)){
  #print(i)
  #print(rlist[i])
  rast1=as.Raster(readRAST6(rlist[i]))
  uncertaintyDiff=data.frame(uncert=((rast1/material.before)@data@values-1)*100)
  uncertaintyDiff["depth"]=as.data.frame(raster(depth.mask))
  ##calculate mean
  uncertaintyStat=aggregate(uncertaintyDiff,list(uncertaintyDiff$depth),FUN=mean,na.rm=T)
  ##plot
  lines(uncertaintyStat$uncert,uncertaintyStat$depth-0.5,col=cols.uncert$col[cols.uncert$run==i])
  #points(uncertaintyStat$uncert,uncertaintyStat$depth,pch=1,col="red")
}
legend("bottomright",legend=timelist$time[start:end],col=cols.uncert$col,lty=1)
```




###Overall changes
Range of all datasets before tracer divided by reference (mean of first five measurements)  
Changes in the uppermost 1m due to irrigation  
Changes below due to artefacts (changing contrast due to irrigation)  
Water front did not reach bedrock (DCPT)  
```{r echo=F,message=F,warning=F}
##############################################################################
##r.series maps
##############################################################################
##do not consider measurements on the folowing day
#execGRASS("r.series",input=rlist[2:length(rlist)],output="total_average",method="average",flag="overwrite")
#execGRASS("r.series",input=rlist[2:length(rlist)],output="total_minimum",method="minimum",flag="overwrite")
#execGRASS("r.series",input=rlist[2:length(rlist)],output="total_maximum",method="maximum",flag="overwrite")
#execGRASS("r.series",input=rlist[2:length(rlist)],output="total_sum",method="sum",flag="overwrite")
#execGRASS("r.series",input=rlist[2:17],output="total_range",method="range",flag="overwrite")

##EXPLORE r.series raster
rastName="total_range"##"total_sum"
rast.series=as.Raster(readRAST6(rastName))
##plot relative range-raster
relRange=rast.series/material.before*100
par(xaxs="i",yaxs="i")
par(mfrow=c(1,1),mar=c(5,5,5,5),oma=c(0,0,0,0),xaxs="i",yaxs="i")
plot(NA,NA,xlim=c(0,250),ylim=c(-150,0),axes=F,xlab="",ylab="",asp=1)
axis(side=1,at=seq(0,250,by=50),labels=seq(0,250,by=50)/10)
mtext(side=1,line=2.5,"Relative distance [m]")
axis(side=2,at=seq(-150,0,by=50),labels=seq(0,150,by=50)/10,las=1)
mtext(side=2,line=2.5,"Relative elevation [m]",las=0)
mtext(side=4,"Relative change [%]",las=0,line=3)
plot(relRange,axes=F,box=F,add=T,asp=1,zlim=c(0,25))
points(dcpt.vect,pch=20,cex=0.5)
points(probesERT,pch=3,cex=0.5)
legend("bottomleft",legend=c("Probes","DCPT"),pch=c(3,20))
```


Mean overall changes with depth  
```{r echo=F,message=F,warning=F}
##plot relative changes with depth
relDiff=data.frame(diff=relRange@data@values)
relDiff["depth"]=as.data.frame(raster(depth.mask))
##calculate mean
relDiffStat=aggregate(relDiff,list(relDiff$depth),FUN=mean,na.rm=T)
##plot
par(mfrow=c(1,1),xaxs="i",yaxs="i")
plot(NA,NA,col="red",type="l",ylim=c(47,0),xlim=c(0,10),axes=F,xlab="",ylab="")

##calculate mean relative uncertainties with depth
abuncert=data.frame(uncert=((rangeERT/material.before)@data@values)*100)
abuncert["depth"]=as.data.frame(raster(depth.mask))
abuncertStat=aggregate(abuncert,list(abuncert$depth),FUN=mean,na.rm=T)
##plot
#lines(relDiffStat$diff-abuncertStat$uncert,abuncertStat$depth-0.5,col="black")
#lines(relDiffStat$diff+abuncertStat$uncert,abuncertStat$depth-0.5,col="black")
polygon(x=na.omit(c(relDiffStat$diff-abuncertStat$uncert,rev(relDiffStat$diff+abuncertStat$uncert))),
        y=na.omit(c(abuncertStat$depth-0.5,rev(abuncertStat$depth-0.5))),col="gray70",border=NA)

##plot line
lines(relDiffStat$diff,relDiffStat$depth-0.5,col="red")

axis(side=1,at=seq(0,10,by=2.5))
mtext(side=1,"Relative changes [%]",line=2.5)
axis(side=2,at=seq(0,50,by=10),labels=seq(0,50,by=10)/10,las=1)
mtext(side=2,"Depth [m]",line=2.5,las=0)
abline(v=seq(2.5,10,by=2.5),lty=2,lwd=0.2,col="gray70")
abline(h=seq(0,50,by=5),lty=2,lwd=0.2,col="gray70")
legend("bottomright",legend=c("Mean overal changes","Mean uncertainty"),col=c("red","gray70"),pch=c(NA,15),lty=c(1,NA))
```


###Build depth mask
Restrict further analysis to upper 2m within irrigation plot (no bias from area outside)  
```{r echo=F,message=F,warning=F}
##raster for irrigatin plot extent
lengthRast=rast0
lengthRast@data@values=length.mask
lengthRast[lengthRast@data@values<plot.min]=NA
lengthRast[lengthRast@data@values>plot.max]=NA
lengthRast[lengthRast@data@values>0]=1
##depth raster
depthRast=rast0
depthRast@data@values=depth.mask
##limit depth to maximum.depth
depthRast[depthRast@data@values>maximum.depth]=NA
##multiply with lateral extent
depthRast=depthRast*lengthRast
##create depthMask
depthMask=depthRast
depthMask[depthMask@data@values>0]=1
#image(depthRast,col=colors)
dcptRast=rast0
dcptRast@data@values=dcpt.mask

##plot
plot(NA,NA,xlim=c(0,250),ylim=c(-150,0),axes=F,xlab="",ylab="",asp=1)
axis(side=1,at=seq(0,250,by=50),labels=seq(0,250,by=50)/10)
mtext(side=1,line=2.5,"Relative distance [m]")
axis(side=2,at=seq(-150,0,by=50),labels=seq(0,150,by=50)/10,las=1)
mtext(side=2,line=2.5,"Relative elevation [m]",las=0)
mtext(side=4,"Relative change [%]",las=0,line=3)
plot(depthRast,axes=F,box=F,add=T,asp=1)

plot(irr_plot,add=T)
points(probesERT,pch=3,cex=0.5)
mtext(side=4,line=4,"Depth [dm]",las=0)
```





###Plot mean relative resistivity ratio with depth for each time step
Data restricted to uppermost 2m within irrigation plot (depth mask)  
Ratio to mean of first five measurements  
```{r echo=F,results=F,message=F,warning=F}
##############################################################################
##PLOTS
##############################################################################
##from start of irrigation
startRaster=2
##until irrigation
endRaster=17
##all measurements
#endRaster=51

depthMax=20
colors.runs=colorRampPalette(rev(brewer.pal(10,"RdYlGn")))((endRaster-startRaster)+1)
range=12##

##pre-plot difference-depth plot
par(las=1)
##negative only
plot(NA,NA,ylim=c(depthMax,0),xlim=c(-(range),0),ylab="Depth [dm]",xlab="Resistivity Ratio [%]",type="l")
abline(v=c(0))

##set extreme values (cut off)
##relative limits
#nochange.min=mean(diff@data@values,na.rm=T)-2*sd(diff@data@values,na.rm=T)
#nochange.max=mean(diff@data@values,na.rm=T)+2*sd(diff@data@values,na.rm=T)
##absolute limits
#nochange.max=40##40##10##
#nochange.min=-nochange.max

##set absolute noise level
#noise.max=mean(noise@data@values,na.rm=T)##0.5
#noise.max=0.26
#noise.min=-noise.max

i=16
ert.time=data.frame()
ert.depth=data.frame(NA)
for (i in seq(startRaster,endRaster,by=1)){
  #print(i)
  #print(sprintf("%s-%s",rlist[i+1],rlist[i]))
  timestep=as.POSIXct(strptime(sprintf("2014-07-24 %s",substr(rlist[i],start=5,stop=nchar(rlist[i]))),"%Y-%m-%d %H_%M_%S"))
  ert.time=rbind(ert.time,timestep)
  ##get difference to data set before
  rast1=as.Raster(readRAST6(rlist[i]))*depthMask
  #rast2=as.Raster(readRAST6(rlist[i+1]))*depthMask

  ##subtraction
  #diff=getDiff(rast1,rast2)
  ##or to first data set
  #diff=getDiff(material.before,rast1)
  
  ##ratio
  ##or to first data set
  diff=(getRatio(material.before,rast1)-1)*100

  ##only negative values
  diff@data@values[diff@data@values>0]=0

  ##plot infiltration
  ##uncertainty 3%
  pdf(sprintf("irrig_%0.2i.pdf",i))
  #png(sprintf("irrig_%0.2i.png",i))
  uncert=-3
  diff.plot=diff
  diff.plot[diff.plot@data@values>=uncert]=0
  par(xaxs="i",yaxs="i",mar=c(1,1,1,1))
  plot(NA,NA,xlim=c(30,190),ylim=c(-150,-10),axes=F,xlab="",ylab="",asp=1)
  #axis(side=1,at=seq(0,250,by=50),labels=seq(0,250,by=50)/10)
  #mtext(side=1,line=2.5,"Relative distance [m]")
  #axis(side=2,at=seq(-150,0,by=50),labels=seq(0,150,by=50)/10,las=1)
  #mtext(side=2,line=2.5,"Relative elevation [m]",las=0)
  #mtext(side=4,"Relative change [%]",las=0,line=3)
  scalebar(20)
  plot(diff.plot,col=colorsERT,add=T,zlim=c(-20,0))
  plot(irr_mask,add=T,lty=2,lwd=0.5)
  plot(irr_border,add=T,lty=2,lwd=0.5)
  points(probesERT,pch=3,cex=0.5)
  points(dcpt.vect,pch=20,cex=0.3)
  text(180,-20,format(timestep,format="%H:%M"),cex=2)
  
  dev.off()
  
  ##data.frame with resistivity and depth
  data=as.data.frame(diff@data@values)
  data["depth"]=as.data.frame(depthRast)
  ##remove nans
  data=data[!is.nan(data$depth),]
  ##calculate mean and sd
  data.mean=aggregate(data,list(data$depth),mean)
  data.sd=aggregate(data,list(data$depth),sd)
  names(data.mean)=c("depth","ratio","depth2")
  ##add to time data frame
  data.append=data.frame(data.mean$ratio)
  names(data.append)=c(sprintf("tstep_%i",i))
  ert.depth=cbind(ert.depth,data.append)

  ##plot mean resistivity and sd with depth
  lines(data.mean$ratio,data.mean$depth-0.5,col=colors.runs[i-startRaster+1],lwd=4)
  #lines(data.mean$ratio+data.sd[,2],data.mean$depth,col=colors.runs[i-startRaster],lty=2)
  #lines(data.mean$ratio-data.sd[,2],data.mean$depth,col=colors.runs[i-startRaster],lty=2)
}
legend("bottomleft",title="Time",legend=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M:%S"),col=colors.runs,lty=1,lwd=4,cex=0.8)
```


Mean resistivity ratio per depth over time  
```{r echo=F,message=F,warning=F}
#colors.depth=colorRampPalette(rev(brewer.pal(10,"RdYlGn")))(ncol(as.data.frame(t(ert.depth[,-1]))))#(9)#
#matplot(x=as.POSIXct(ert.time[,1],origin="1970-01-01"),as.data.frame(t(ert.depth[,-1])),type="l",ylab="Resistivity difference [Ohm m]",xlab="Time",ylim=c(roundDown(min(ert.depth[,-1]),1),0),col=colors.depth,lty=1,axes=F)

##only plot first 10 depths
colors.depth=colorRampPalette(rev(brewer.pal(10,"RdYlBu")))(10)
depth.steps=c("0 - 10","10 - 20","20 - 30","30 - 40","40 - 50","50 - 60","60 - 70","70 - 80","80 - 90","90 - 100")
matplot(x=as.POSIXct(ert.time[,1],origin="1970-01-01"),as.data.frame(t(ert.depth[,-1]))[1:10],type="l",ylab="Resistivity ratio [%]",xlab="Time",ylim=c(roundDown(min(ert.depth[,-1]),1),0),col=colors.depth,lty=1,lwd=2,axes=F)
axis(side=1,at=as.POSIXct(ert.time[,1],origin="1970-01-01"),labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"),las=2)
axis(side=2,at=seq(roundUp(max(ert.depth[,-1]),1),roundDown(min(ert.depth[,-1]),10),by=-5))
legend("bottomleft",title="Depth [cm]",legend=depth.steps,col=colors.depth,lty=1,lwd=2)
##############################################################################
```



###Recorded TDR data
TDR at depth 40 did not record meaningful data
```{r echo=F,message=F,warning=F}
##############################################################################
##plot tdr data
##############################################################################
setwd(TDRPath)

minY=32
maxY=44

##set data source
data.raw=read.table("bonacker_2.txt",sep="\t",header=T,stringsAsFactors=F)
##profile 1
#probes=data.frame(nr=c(9,12,10,11),depth=c(20,40,55,80))
##profile 2
probes=data.frame(nr=c(16,14,13),depth=c(20,60,75))##omit probe at depth 40; 15,40,

##set measure day
measureday="2014-07-24 00:00:00"

##reformat date
data.raw["date_ref"]=paste(data.raw$date,data.raw$time,sep=" ")
data.raw["date_ref2"]=as.POSIXct(data.raw$date_ref,format="%d.%b.%y %H:%M:%S")

cols=c("vol","probe","date_ref2")
dataTDR=data.raw[cols]
names(dataTDR)=c("vol","probe","date")
dataTDR=dataTDR[dataTDR$probe%in%probes$nr,]

##subset date
day=as.POSIXct(measureday,format="%Y-%m-%d %H:%M:%S")
dataTDR=dataTDR[format(dataTDR$date,format="%Y-%m-%d %H:%M:%S")>=day,]
dataTDR=dataTDR[format(dataTDR$date,format="%Y-%m-%d")==as.POSIXct(measureday,format="%Y-%m-%d"),]

##set mindate and maxdate
mindate=as.POSIXct(strptime("2014-07-24 12:00:00",format="%Y-%m-%d %H:%M:%S"))
maxdate=as.POSIXct(strptime("2014-07-24 20:00:00",format="%Y-%m-%d %H:%M:%S"))

##omit zeros
dataTDR$vol[dataTDR$vol==0]=NA

##settings
par(mar=c(4,6,4,4),las=1)

plot(NA,NA,type="l",ylim=c(minY,maxY),xlim=c(mindate,maxdate),ylab="",xlab="",axes=F)
probes["cols"]=rev(colorRampPalette(brewer.pal(10,"RdYlBu"))(nrow(probes)))
dataProbes=qpcR:::data.frame.na(NA)
##probe=3
for (probe in probes$nr){
  ##print(probe)
  data.probe=dataTDR[dataTDR$probe==probe,][c(1,3)]
  data.probe["time"]=as.double(data.probe[,2])-(as.numeric(as.POSIXct(strptime(measureday,format="%Y-%m-%d %H:%M:%S")))+12*60*60)
  names(data.probe)=c(sprintf("vol_%s",probe),sprintf("date_%s",probe),sprintf("time_%s",probe))
  dataProbes=qpcR:::cbind.na(dataProbes,data.probe)
  ##plot measurements
  lines(data.probe$date,
        data.probe$vol,
        col=probes$cols[probes$nr==probe],
        lty=2
  )
  ##plot mean
  filtered=filter(data.probe$vol,rep(1/7,7),method="convolution",sides=2)
  lines(data.probe$date,
        filtered,
        col=probes$cols[probes$nr==probe],
        lwd=2)
}
dataProbes=dataProbes[,-1]
##axes
xticks=seq(from=as.POSIXct(format(mindate,format="%Y-%m-%d %H"),format="%Y-%m-%d %H"),to=as.POSIXct(format(maxdate,format="%Y-%m-%d %H"),format="%Y-%m-%d %H"),"hours",cex=0.8)
axis.POSIXct(side=1,at=xticks,format="%H:00",las=2,cex=0.8)
axis(side=2,at=seq(minY,maxY,5))
mtext(side=2,"Saturation [%]",las=0,line=3,cex=0.8)
##grid
abline(v=xticks,lty=2,lwd=0.5,col="gray70")
abline(h=seq(minY,maxY,10),lty=2,lwd=0.5,col="gray70")

legend("bottomright",title="Depth [cm]",legend=probes$depth,lwd=2,lty=1,col=probes$cols,bty="n",cex=0.8)


##reformat tdr records
##get mean of TDR measurements 1h before irrigation
TDRbefore=subset(dataProbes,(dataProbes[,2]>=as.POSIXct(measureday)+(12*60*60))&(dataProbes[,2]<=as.POSIXct(measureday)+(14*60*60)))[seq(1,ncol(dataProbes),by=3)]
##get mean of TDR measurements 1h after irrigation
TDRafter=subset(dataProbes,(dataProbes[,2]>=as.POSIXct(measureday)+(15*60*60))&(dataProbes[,2]<=as.POSIXct(measureday)+(19*60*60)))[seq(1,ncol(dataProbes),by=3)]
#boxplot(TDRafter)
#mean(colMeans(TDRafter))

TDRdata=rbind(data.frame(vol=TDRbefore[,1],depth=rep(probes$depth[probes$nr==as.numeric(substr(names(TDRbefore)[1],5,7))])),
      data.frame(vol=TDRbefore[,2],depth=rep(probes$depth[probes$nr==as.numeric(substr(names(TDRbefore)[2],5,7))])),
      data.frame(vol=TDRbefore[,3],depth=rep(probes$depth[probes$nr==as.numeric(substr(names(TDRbefore)[3],5,7))])))

TDRdataAfter=rbind(data.frame(vol=TDRafter[,1],depth=rep(probes$depth[probes$nr==as.numeric(substr(names(TDRafter)[1],5,7))])),
      data.frame(vol=TDRafter[,2],depth=rep(probes$depth[probes$nr==as.numeric(substr(names(TDRafter)[2],5,7))])),
      data.frame(vol=TDRafter[,3],depth=rep(probes$depth[probes$nr==as.numeric(substr(names(TDRafter)[3],5,7))])))
```


###Compare soil moisture and resistivity
...not necessary for further steps, but interesting...  
1. Fitting of a scaled logistic time-dependent model to variation of resistivity ratio in the depths corresponding to the TDR depths  
2. Extraction of the resistivity values corresponding to the time of TDR measurements  
3. Comparison of resistivity ratio and corresponding volumetric water content and fitting a linear model (poly, exp etc. does not yield better results...)  
```{r echo=F,message=F,warning=F}
##############################################################################
##Compare decrease in resistivity with increase in soil moisture
##############################################################################
depthList=c(20,60)#,75)
depthcols=colorRampPalette(rev(brewer.pal(10,"RdYlGn")))(length(depthList))
depths=data.frame(depth=depthList,cols=depthcols,stringsAsFactors=F)
par(xaxs="i",yaxs="i",pty="s")
#plot(NA,NA,,xlim=c(30,45),ylim=c(0,-40),ylab="Resistivity difference [Ohm m]",xlab="Soil moisture [Vol%]")
depth=20
for (depth in depths$depth){
  ##data of desired depth
  depthData=as.data.frame(t(ert.depth[,-1]))[round(depth/10)]
  names(depthData)=c("resDiff")
  
  ##get time for measurements (begin/end??)
  depthData["time"]=timelist$time[startRaster:endRaster]
  depthData["date"]=as.POSIXct(strptime(paste(substr(measureday,1,10),depthData$time,sep=" "),format="%Y-%m-%d %H:%M"))
 
  ##get time in seconds relative to measureday 12:00:00
  depthData["seconds"]=as.numeric(as.POSIXct(depthData$date))-(as.numeric(as.POSIXct(strptime(measureday,format="%Y-%m-%d %H:%M:%S")))+12*60*60)
  
  ##temporal data integration
  ##fit scaled logistic model
  Fit=nls(resDiff~-c*(1/(1+exp(a+b*seconds))),
          start=list(a=1,b=0.00001,c=10),
          data=depthData,algorithm="port",
          nls.control(minFactor=1/8192,maxiter=50),trace=F)
  #summary(Fit)
  ##plot model
  fitData=data.frame(seconds=seq(min(depthData$seconds),max(depthData$seconds),by=1))
  fitData["resist"]=-coef(Fit)[3]*(1/(1+exp(coef(Fit)[1]+coef(Fit)[2]*fitData$seconds)))
  plot(depthData$seconds,depthData$resDiff,type="p",ylim=c(-10,0),ylab="",xlab="",las=1,axes=F)
  axis(side=1,at=depthData$seconds,labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"),las=2)
  axis(side=2,at=seq(0,-10,-2),las=1)
  mtext(side=2,"Resistivity ratio [%]",line=2.5,las=0)
  lines(fitData$seconds,fitData$resist,col="red")

  
  ##tdr data at depth
  dataTDR.sub=dataTDR[dataTDR$probe==probes$nr[probes$depth==depth],]
  ##get time in seconds from measureday 12:00:00
  dataTDR.sub["seconds"]=as.numeric(as.POSIXct(dataTDR.sub$date))-(as.numeric(as.POSIXct(strptime(measureday,format="%Y-%m-%d %H:%M:%S")))+12*60*60)
  fused=merge(subset(dataTDR.sub,seconds%in%fitData$seconds),subset(fitData,seconds%in%dataTDR.sub$seconds),by="seconds")
  plot(NA,NA,xlim=c(32,42),ylim=c(0,-10),ylab="Resistivity ratio [%]",xlab="Soil moisture [Vol%]",las=1)
  points(fused$vol,fused$resist,col=depths$cols[depths$depth==depth])
  
  linFit=lm(resist~vol,data=fused)
  ##summary(linFit)
  abline(linFit,col=depths$cols[depths$depth==depth])
  
  ##fit after beff et al. 2013 (did not work, alternative)
  ##however, it always results in a linear relationship...
#   settings=nls.control(maxiter=100,minFactor=1/(1024*10))
#   expFit=nls(-resist~a*exp(vol/100.0)+b,
#              data=fused,
#              algorithm="port",
#              start=list(a=2,b=1),
#              trace=T,
#              settings)
#   x=seq(30,50,1)
#   y=coef(expFit)[1]*exp(x/100)+coef(expFit)[2]
#   lines(x,-y)
}
#legend("bottomright",legend=depths$depth,title="Depth [cm]",col=depths$cols,pch=c(1,1,1),lty=c(1,1,1))
legend("bottomright",legend=depth,title="Depth [cm]",col=depths$cols,pch=c(1,1,1),lty=c(1,1,1))
print(sprintf("R-squared: %0.3f",summary(linFit)$r.squared))
```


###Fit SWCC to data
```{r echo=F,message=F,warning=F}
#################################################################################################
##FIT SWCC
#################################################################################################
setwd(SWCCPath)

require(minpack.lm)

##read data
file="swcc_Laterns_BfW.txt"
data=read.table(file,header=T,stringsAsFactors=F)

##read x-axis (potential in hPa)
potential=data[,1]

##van genuchten model (van Genuchten 1980)
vanGenuchten=function(psi,theta_r,theta_s,alpha,n){
  theta_r+((theta_s-theta_r)/(1.0+(alpha*abs(psi))**n)**(1.0-(1.0/n)))
}

##reverse van genuchten model (van Genuchten 1980)
revVanGenuchten=function(vol,theta_r,theta_s,alpha,n){
  10^((((theta_s-theta_r)/(vol-theta_r))^(1/(1-(1/n)))-1)^(1/n)/alpha)
  #theta_r+((theta_s-theta_r)/(1.0+(alpha*abs(psi))**n)**(1.0-(1.0/n)))
}

##gardner model (Gardner 1959)
Gardner=function(psi,theta_r,theta_s,alpha){
  theta_r+((theta_s-theta_r)**((alpha*(psi+1/alpha))))
}

##PLOT DATA
par(mfrow=c(1,1),las=1,mar=c(4,4,4,4))
##test fitting
element="Bonacker1"#Fur"##"gem"##
subdata=na.omit(data[,grep(element,names(data))])
##define NAs
subdata[subdata=="NA"]<-NA
##calculate mean curve
means=as.data.frame(cbind(as.numeric(row.names(subdata)),rowMeans(subdata)),stringsAsFactors=F)
names(means)=c("potential","mean")
##plot all curves
matplot(subdata,means$potential,xlim=c(0,0.8),type="b",pch=20,lty=1,lwd=1,cex=1,ylim=c(0,log10(max(potential))+1),col=seq(1,ncol(subdata)),xlab="water content [m3/m3]",ylab="PF")
##add mean curve
lines(means$mean,means$potential,xlim=c(0,0.8),type="b",pch=19,lwd=2,lty=3)
#plot(means$mean,means$potential,xlim=c(0,0.8),ylim=c(0,7),type="b",pch=19,lwd=2,lty=3)
##add legend
#legend("topright",inset=0.01,legend=c(names(subdata),"MEAN"),pch=1,col=c(1,2,3,4,5),horiz=F,box.col="white")
legend("topright",title="Laboratory tests",inset=0.01,legend=c(names(subdata)),lty=1,pt.cex=2,cex=1,col=seq(1,ncol(subdata)),horiz=F,box.col="white")
grid()


##VAN GENUCHTEN FIT
##single measurement
# column=4
# data.fit=data.frame(potential=as.numeric(row.names(subdata)),vol=subdata[,column])
##mean
data.fit=data.frame(potential=means$potential,vol=means$mean)
##omit measurement at 1bar (outlier?)
data.fit=data.fit[-1,]
##set start values
startvalues=list(theta_r=0.15,theta_s=0.5,alpha=0.015,n=1.2)
settings=nls.control(maxiter=1000,
                     minFactor=1/2048,
                     tol=1e-5,
                     warnOnly=F,
                     printEval=T)

genuchtenFit=nls(vol~vanGenuchten(10^potential,theta_r,theta_s,alpha,n),
        data=data.fit,
        start=startvalues,
        algorithm="port",
        lower=c(0.1,0.45,0.005,1.0),
        upper=c(0.5,0.6,0.5,70),
        trace=F,#T,
        settings
)
psi=seq(0,5,by=0.1)
wc=vanGenuchten(10^psi,coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])
lines(wc,psi,type="l",xlim=c(0,0.8),ylim=c(0,5),col="blue",lwd=2)

##convert soil moisture (tdr) to suction via van genuchten (1980)
TDRdata["suction"]=revVanGenuchten(TDRdata$vol/100.0,coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])/-100
TDRdata["depthm"]=TDRdata$depth/100.0
TDRdataAfter["suction"]=revVanGenuchten(TDRdataAfter$vol/100.0,coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])/-100
TDRdataAfter["depthm"]=TDRdataAfter$depth/100.0







ktheta=function(theta,n){
  m=1-1/n
  ks=theta^(0.5)*(1-(1-(theta^(1/m)))^(m))^2
  return(ks)
}

theta=seq(0,0.55,0.01)
plot(theta,
     ktheta(theta,coef(genuchtenFit)[4]),
     #ylim=c(1,10000),
     type="l",
     xlab="saturation",
     ylab="hyd. conductivity",
     log="y"
)


diffus=function(ks,theta,theta_r,theta_s,alpha,n){
  m=1-1/n
  d0=(((1-m)*ks)/(alpha*m*(theta_s-theta_r)))*
    (theta^(0.5-(1/m)))*
    (((1-theta^(1/m))^(-1*m))+((1-theta^(1/m))^m)-2)
  return(d0)
}

ks=0.00025
diffus(ks,theta,coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])

plot(theta,
     diffus(ks,theta,coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4]),
     #ylim=c(1,10000),
     type="l",
     xlab="saturation",
     ylab="hyd. diffusivity",
     log="y"
)


##fit linear model to soil suction with depth (tension-saturation)
suctionFit=lm(suction~depthm,data=TDRdata)
par(xaxs="i",yaxs="i",mar=c(4,5,4,6),pty="s")
depth=seq(0,1.5,0.01)
plot(NA,NA,ylim=c(1,0),xlim=c(-30,0),xlab="",ylab="")
mtext(side=1,"Soil suction [m]",line=2.5)
mtext(side=2,"Depth [m]",line=3,las=0)
##first plot 95% ci's
ciSuction=predict(lm(suction~depthm,data=TDRdata),newdata=data.frame(depthm=depth),interval=c("confidence"),level=0.95)
ciSuction2=predict(lm(suction~depthm,data=TDRdataAfter),newdata=data.frame(depthm=depth),interval=c("confidence"),level=0.95)
polygon(c(ciSuction[,2],rev(ciSuction[,3])),c(depth,rev(depth)),border=F,col="gray80")
polygon(c(ciSuction2[,2],rev(ciSuction2[,3])),c(depth,rev(depth)),border=F,col="gray80")
##plot lms
points(TDRdata$suction,TDRdata$depthm,pch=3,cex=0.7,col="red")
points(TDRdataAfter$suction,TDRdataAfter$depthm,pch=2,cex=0.7,col="blue")
lines(ciSuction[,1],depth,type="l",col="red",lwd=2)
lines(ciSuction2[,1],depth,type="l",col="blue",lwd=2)

##fit linear model and extrapolate initial water content
Suctionexp=data.frame(depth=seq(0,100,10),Suctionexp1=predict(lm(suction~depth,data=TDRdata),newdata=data.frame(depth=seq(0,100,10))),Suctionexp2=predict(lm(suction~depth,data=TDRdataAfter),newdata=data.frame(depth=seq(0,100,10))))




##now calculate water content with depth
waterDepth=data.frame(watercontent1=vanGenuchten(log10(-ciSuction[,1][1:100]*100),coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])*100,
                      watercontent2=vanGenuchten(log10(-ciSuction2[,1][1:100]*100),coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])*100,
                      depth=depth[1:100]*100)

##fit linear model and extrapolate initial water content
TDRexp=data.frame(depth=seq(0,100,10),volexp1=predict(lm(vol~depth,data=TDRdata),newdata=data.frame(depth=seq(0,100,10))),volexp2=predict(lm(vol~depth,data=TDRdataAfter),newdata=data.frame(depth=seq(0,100,10))))

##plot soil moisture with depth before and after irrigation
plot(NA,NA,ylim=c(100,0),xlim=c(32,42),xlab="",ylab="")
mtext(side=1,"Water content [%]",line=2.5)
mtext(side=2,"Depth [cm]",line=3,las=0)
##first plot 95% ci's
ci=predict(lm(vol~depth,data=TDRdata),newdata=data.frame(depth=0:100),interval=c("confidence"),level=0.95)
ci2=predict(lm(vol~depth,data=TDRdataAfter),newdata=data.frame(depth=0:100),interval=c("confidence"),level=0.95)
#ci=predict(lm(vol~depth,data=TDRdata),newdata=data.frame(depth=0:100),interval=c("prediction"),level=0.95)
#ci2=predict(lm(vol~depth,data=TDRdataAfter),newdata=data.frame(depth=0:100),interval=c("prediction"),level=0.95)
polygon(c(ci[,2],rev(ci[,3])),c(0:100,100:0),border=F,col="gray80")
polygon(c(ci2[,2],rev(ci2[,3])),c(0:100,100:0),border=F,col="gray80")
##plot lms
points(TDRdata$vol,TDRdata$depth,pch=3,cex=0.7,col="red")
lines(ci[,1],seq(0,100),type="l",col="red",lwd=2)
points(TDRdataAfter$vol,TDRdataAfter$depth,pch=2,cex=0.7,col="blue")
lines(ci2[,1],seq(0,100),type="l",col="blue",lwd=2)
legend("bottomleft",legend=c("Before irrigation","After irrigation"),pch=c(3,2),lty=c(1,1),col=c("red","blue"))


lines(waterDepth$watercontent1,
     waterDepth$depth,
     type="l",
     ylim=c(100,0),
     xlim=c(32,42))
lines(waterDepth$watercontent2,
     waterDepth$depth,
     type="l",
     ylim=c(100,0),
     xlim=c(32,42))




# gardenerFit=nls(vol~Gardner(potential,theta_r,theta_s,alpha),
#         data=data.fit,
#         start=list(theta_r=0.15,theta_s=0.5,alpha=0.15),
#         algorithm="port",
#         lower=c(0.0,0.45,0.05),
#         upper=c(0.4,0.7,1),
#         trace=F,#T,
#         settings
# )
# psi=seq(0,5,by=0.2)
# wc=Gardner(psi,coef(gardenerFit)[1],coef(gardenerFit)[2],coef(gardenerFit)[3])
# lines(wc,psi,type="l",xlim=c(0,0.8),ylim=c(0,5),col="blue",lwd=2,lty=2)
# 
# #wc=Gardner(psi,0.2,0.55,20)
# #lines(wc,psi,type="l",xlim=c(0,0.8),ylim=c(0,5),col="red")
# legend("bottomleft",legend=c("Mean curve","van Genuchten Fit","Gardner Fit"),lty=c(3,1,2),lwd=c(2,2,2),pch=c(19,NA,NA),col=c("black","blue","blue"))
```



###Convert Resistivity Ratios to Water content  
Initial state: linear inter-/extrapolation of recorded water content before irrigation (TDRs) with depth  
```{r echo=F,message=F,warning=F}
##depth step to be considered
depthWater=10
rRatio=ert.depth[1:depthWater,-1]

##use linear relationship of resistivity ratio and water content (does not work!)
#coef(linFit)[2]
##calculate ratio change between time steps
# tempRatio=data.frame()
# for (i in 2:nrow(rRatio)){
#   tempRatio=rbind(tempRatio,rRatio[i,]-rRatio[i-1,])
# }
# colnames=c()
# for (i in 1:ncol(rRatio)){
#   colnames=c(colnames,sprintf("X%i",i))
# }
# names(tempRatio)=colnames
# matplot(tempRatio,type="l")



##Final state: interpolated water content after irrigation  
##scale restistivity ratios to water content
scaleRatio=data.frame()
scaleRatioRel=data.frame()
##same max. value in all depths, derived from mean of all measurements after no change with irrigation (15.00h)
#TDRmax=mean(colMeans(TDRafter))
depth=1
for (depth in 1:nrow(rRatio)){
  ##interpolated water content before irrigation
  TDRmin=TDRexp$volexp1[depth]
  ##interpolated water content after irrigation
  TDRmax=TDRexp$volexp2[depth]
  ##target scale
  scaleTDR=TDRmax-TDRmin
  
  ##resistivity ratios in depth
  ratios=rRatio[depth,]
  ratiosMin=ratios[1]
  ratiosMax=ratios[length(ratios)]
  ##scaled ratios
  ratiosScaled=TDRmin+(ratios-rep(ratiosMin,length(ratios)))/rep(ratiosMax-ratiosMin,length(ratios))*scaleTDR
  ratiosScaledRel=(ratios-rep(ratiosMin,length(ratios)))/rep(ratiosMax-ratiosMin,length(ratios))*scaleTDR
  ##and append to data.frame
  scaleRatio=rbind(scaleRatio,ratiosScaled)
  scaleRatioRel=rbind(scaleRatioRel,ratiosScaledRel)
}
matplot(t(scaleRatio),type="l",ylab="",xlab="",axes=F,col=colors.depth,lty=1,ylim=c(34,40))
axis(side=1,at=seq(1:ncol(scaleRatio)),labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"),las=2)
axis(side=2,at=seq(34,40,1),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Water content [%]",line=2.5,las=0)
legend("bottomright",title="Depth [cm]",legend=depth.steps,col=colors.depth,lty=1,lwd=2,cex=0.7)

matplot(t(scaleRatio),type="l",ylab="",xlab="",axes=F,col=colors.depth,lty=1,ylim=c(34,40))
axis(side=1,at=seq(1:ncol(scaleRatio)),labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"),las=2)
axis(side=2,at=seq(34,40,1),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Water content [%]",line=2.5,las=0)
legend("bottomright",title="Depth [cm]",legend=depth.steps,col=colors.depth,lty=1,lwd=2,cex=0.7)


###Plot water content with depth over time  
##build matrix
RatioData=as.matrix(scaleRatio)
RatioDataRel=as.matrix(scaleRatioRel)

##rasterize matrix
RatioDatarast=raster(RatioData)
RatioDataRelrast=raster(RatioDataRel)

par(mfrow=c(1,1))
##plot absolute change
par(xaxs="i",yaxs="i",mar=c(4,5,4,6))
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
axis(side=1,at=seq(1:ncol(scaleRatio))/10,labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"))
axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Depth [m]",line=2.5,las=0)
mtext(side=4,line=4,"Water content [%]",las=0)
plot(RatioDatarast,col=rev(colors),add=T,zlim=c(34,40))


##plot relative change
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
axis(side=1,at=seq(1:ncol(scaleRatio))/10,labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"))
axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Depth [m]",line=2.5,las=0)
##cut off negative values
RatioDataRelrast[RatioDataRelrast<0]=0
mtext(side=4,line=4,"Change in water content [%]",las=0)
plot(RatioDataRelrast,col=rev(colors),add=T,zlim=c(0,5))
```



###Scale restistivity ratios to suction directly (skipping water content) 
Initial state: linear inter-/extrapolation of converted soil suction before irrigation with depth  
```{r echo=F,message=F,warning=F}
##depth step to be considered
depthWater=10
rRatio=ert.depth[1:depthWater,-1]

##scale restistivity ratios to suction directly (skipping water content)
scaleRatio=data.frame()
scaleRatioRel=data.frame()
##same max. value in all depths, derived from mean of all measurements after no change with irrigation (15.00h)
#TDRmax=mean(colMeans(TDRafter))
depth=1
for (depth in 1:nrow(rRatio)){
  ##interpolated water content before irrigation
  Suctionmin=Suctionexp$Suctionexp1[depth]
  ##interpolated water content after irrigation
  Suctionmax=Suctionexp$Suctionexp2[depth]
  ##target scale
  scaleTDR=Suctionmax-Suctionmin
  
  ##resistivity ratios in depth
  ratios=rRatio[depth,]
  ratiosMin=ratios[1]
  ratiosMax=ratios[length(ratios)]
  ##scaled ratios
  ratiosScaled=Suctionmin+(ratios-rep(ratiosMin,length(ratios)))/rep(ratiosMax-ratiosMin,length(ratios))*scaleTDR
  ratiosScaledRel=(ratios-rep(ratiosMin,length(ratios)))/rep(ratiosMax-ratiosMin,length(ratios))*scaleTDR
  ##and append to data.frame
  scaleRatio=rbind(scaleRatio,ratiosScaled)
  scaleRatioRel=rbind(scaleRatioRel,ratiosScaledRel)
}
matplot(t(scaleRatio),type="l",ylab="",xlab="",axes=F,col=colors.depth,lty=1,ylim=c(-30,-5))
axis(side=1,at=seq(1:ncol(scaleRatio)),labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"),las=2)
axis(side=2,at=seq(-30,-5,5),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Pressure head [m]",line=2.5,las=0)
legend("bottomright",title="Depth [cm]",legend=depth.steps,col=colors.depth,lty=1,lwd=2,cex=0.7)


###Plot water content with depth over time  
##build matrix
RatioData=as.matrix(scaleRatio)
RatioDataRel=as.matrix(scaleRatioRel)

##rasterize matrix
RatioDatarast=raster(RatioData)
RatioDataRelrast=raster(RatioDataRel)

par(mfrow=c(1,1))
##plot absolute change
par(xaxs="i",yaxs="i",mar=c(4,5,4,6))
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
axis(side=1,at=seq(1:ncol(scaleRatio))/10,labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"))
axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Depth [m]",line=2.5,las=0)
mtext(side=4,line=4,"Water content [%]",las=0)
plot(RatioDatarast,col=rev(colors),add=T,zlim=c(-30,-5))


##plot relative change
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
axis(side=1,at=seq(1:ncol(scaleRatio))/10,labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"))
axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Depth [m]",line=2.5,las=0)
##cut off negative values
RatioDataRelrast[RatioDataRelrast<0]=0
mtext(side=4,line=4,"Change in water content [%]",las=0)
plot(RatioDataRelrast,col=rev(colors),add=T,zlim=c(0,15))
```






Calculate suction via fitted van Genuchten model  
```{r echo=F,message=F,warning=F}
##reverse van genuchten model (van Genuchten 1980)
# revVanGenuchten=function(vol,theta_r,theta_s,alpha,n){
#   10^((((theta_s-theta_r)/(vol-theta_r))^(1/(1-(1/n)))-1)^(1/n)/alpha)
#   #theta_r+((theta_s-theta_r)/(1.0+(alpha*abs(psi))**n)**(1.0-(1.0/n)))
# }
# 
# ##plot(seq(0,1,0.01),revVanGenuchten(seq(0,1,0.01),coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4]),log="y")
# suction.sub=revVanGenuchten(data.frame(RatioData/100.0),coef(genuchtenFit)[1],coef(genuchtenFit)[2],coef(genuchtenFit)[3],coef(genuchtenFit)[4])
# min(data.frame(RatioData/100.0))
# max(data.frame(RatioData/100.0))
# 
# 
# ##convert to m Wassersaeule
# suction.sub=suction.sub/-100.0
# min(suction.sub)
# max(suction.sub)
# 
# ##rasterize matrix
# Suctionrast=raster(suction.sub)
# 
# par(xaxs="i",yaxs="i",mar=c(4,5,4,6))
# plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
# axis(side=1,at=((1/ncol(scaleRatio)/2)+seq(0,(ncol(scaleRatio)-1),1)/ncol(scaleRatio)),labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"),las=2)
# axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
# mtext(side=1,"Time",line=2.5)
# mtext(side=2,"Depth [m]",line=2.5,las=0)
# mtext(side=4,line=5,"Pressure head [m]",las=0)
# #Suctionrast@data@values[Suctionrast@data@values>-10.0]=-10.0
# plot(Suctionrast,col=rev(colors),add=T,zlim=c(-30,-10))
```


###Compare to model results
Tension-saturated initial conditions  
```{r echo=F,message=F,warning=F}
##validation data (observations)
Suctionrast=RatioDatarast

##initial conditions
##initial depth of water table
initFit=lm(suction~depthm,data=TDRdata)
coef(initFit)[1]/coef(initFit)[2]

##beta for initial conditions
coef(initFit)[2]

##regolith depth
zmax=2
##starting depth
zmin=0.1
##depth increment
zstep=0.1
##depth of water table
d=-coef(initFit)[1]/coef(initFit)[2]

##slope angle (to radian)
slope=31.3*pi/180

##time
time=c(0,420,820,1260,1680,2100,2520,2940,3360,3780,4200,4620,5040,5460,5880,6300,6720)
#time=c(0,0,0,420,820,1260,1680,2100,2520,2940,3360,3780,4200,4620,5040,5460,5880,6300,6720)

##precipitation (27.5 mm/h)
iz=c(0.0,0.0,0.0,0.0,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889)

##number of time steps
tsteps=length(time)
nper=length(iz)

##coordiante transformation for slope-parallel ground water flow
#beta=cos(slope)^2
beta=coef(initFit)[2]

##beta-line (saturated)
psi0=(seq(zmin,zmax,zstep)-d)*beta
par(xaxs="i",yaxs="i")
#plot(psi0,seq(zmin,zmax,zstep),type="l",xlim=c(-40,0),ylim=c(zmax,0),ylab="Depth [m]",xlab="Pressure head [m]")
##beta-line (initial)
psisat=(seq(zmin,zmax,zstep))*beta
#lines(psisat,seq(zmin,zmax,zstep))
#abline(v=0)



##par(pty="s")
##plot(expand.grid(c(10^(seq(0,1,length.out=5)) %o% 10^(-8:-5)),c(10^(seq(0,1,length.out=5)) %o% 10^(-8:-5))),log="xy")

corelList=data.frame()
for (ks in unique(c(10^(seq(0,1,0.1)) %o% 10^(-8:-4)))){
  print(ks)
  for (ss in unique(c(10^(seq(0,1,0.1)) %o% 10^(-5:-2)))){
    ##hydraulic diffusivity
    d0=ks/ss

    ##correction of the original Iverson (2000) formula dm=4.0*d0*beta
    ##see Baum et al. 2010
    dm=4.0*d0/cos(slope)^2
    
    ##all pwp time steps
    pwpTime=data.frame()
    
#     #own scripts ()
#     cols=rev(topo.colors(tsteps))
#     for (tstep in 1:(nper)){
#       tstar1=time[tstep]/(seq(zmin,zmax,zstep)^2/dm)
#       rstar1=(tstar1/pi)^0.5*exp(-1/tstar1)-erfc(1/(tstar1^0.5))
#       psistep1=beta*(1-d/seq(zmin,zmax,zstep))+iz[tstep]/ks*rstar1
#       psi1=seq(zmin,zmax,zstep)*psistep1
#       
#       ##limit is saturated beta-line
#       psi1[psi1>psisat]=psisat[psi1>psisat]
#       #print(psi1)
#       
#       pwpTime=rbind(pwpTime,psi1)
#     }
    
    
    
    
    
    cols=rev(topo.colors(tsteps))
    tdata=data.frame(NA)
    ptrans=0.0
    for (tstep1 in 1:(nper+1)){
      t0=time[tstep1]
      zdata=data.frame()
      for (z in seq(zmin,zmax,zstep)){
        pzero=beta*(z-d)
        zstar=z**2/(4.*d0/cos(slope)^2)
        tstar=t0/zstar
        psi=0.0
        for (tstep2 in 1:nper){
          captstar1=time[tstep2]/zstar 
          tdif1=tstar-captstar1
          if(tdif1 > 0.0){
            rfa=((tdif1/pi)^0.5)*exp(-1./tdif1)-erfc(1./((tdif1)^0.5))
          }else{
            rfa=0.0
          }
          captstar2=time[tstep2+1]/zstar
          tdif2=tstar-captstar2
          if (tdif2 > 0.0){
            rfb=((tdif2/pi)^0.5)*exp(-1./tdif2)-erfc(1./((tdif2)^0.5))
          }else{
            rfb=0.0
          }
          #psi=psi+iz[tstep2]/ks*(rfa-rfb)
          psi=psi+iz[tstep2]/ks*(rfa-rfb)*z
        }
        pmax=z*beta
        if (abs(psi)>0.0){
          ptrans=psi
        }
        p=pzero+ptrans
        if (p>pmax){
          p=pmax
        }
        zdata=rbind(zdata,p)
      }
      #lines(zdata[,1],seq(zmin,zmax,zstep),col=cols[tstep1])
      tdata=cbind(tdata,zdata)
      
    #   if(rikzero(i)<0.0) then
    #   zinc=(zmax(i)-zmin)/zns
    #   z=zmin
    #   newdep=0.0
    #   do j=1,nzs+1
    #   if(p(j)<0.0) newdep=z
    #   z=z+zinc
    #   end do
    #   
    #   ! adjust presures 
    #   z=zmin
    #   do j=1,nzs+1
    #   if(p(j)>0.0 .and. z<newdep) p(j)=0.d0
    #   if(p(j)>=0.0 .and. z>=newdep) p(j)=beta*(z-newdep)
    #   z=z+zinc	    
    #   end do
    #   end if
    }
    pwpTime=t(tdata[,c(-1,-length(time))])
    
    
    
    data.c=pwpTime
    ##create color ramp
    cols=colorRampPalette(brewer.pal(3,"RdBu"))(100)
    ##convert to matrix
    data.m=as.matrix(t(data.c)[1:10,])
    data.r=raster(data.m)
    
    ##stack rasters and compute correlation coefficient
    raststack=stack(data.r,Suctionrast)
    corel=layerStats(raststack,'pearson')
    corel$'pearson correlation coefficient'
    corel
    corelList=rbind(corelList,data.frame(ks=ks,ss=ss,d0=d0,cor=corel$"pearson correlation coefficient"[1,2]))
  }
}

wireframe(cor~log10(ss)*log10(ks),
          corelList,drape=T,aspect=c(1,1),
          colorkey=T,col.regions=colorRampPalette(brewer.pal(5,"RdYlGn"))(100),
          screen=list(z=20,x=-50),
          zlab=list("Pearson's correlation coefficient", rot=95),
          xlab=list("LOG10 Specific storage [1/m]",rot=15),
          ylab=list("LOG10 Hydraulic conductivity [m/s]",rot=293),
          scales = list(arrows = FALSE))


best=corelList[corelList$cor==max(corelList$cor),]

##parameter boxplot for correlation >=0.95
boxplot(log10(corelList[corelList$cor>=0.95,]$ks),
        log10(corelList[corelList$cor>=0.95,]$ss),
        log10(corelList[corelList$cor>=0.95,]$d0),
        names=c("Kz","Ss","D0"),
        ylim=c(-8,-1))


##ss for clay after lu and godt 2013, p.118W
n=0.5108
rho_solid=2.68

rho_sat=(rho_solid*(1-n)+n)*1000
alpha_s=0.00000536
9.80665*rho_sat*(alpha_s+n*4.4e-10)

##Ss for clay after Domenico & Mifflin 1965, p.566
alpha_s1=2.08854E-06
alpha_s2=1.30534E-07
ssmax=log10(9.80665*rho_sat*(alpha_s1+n*4.4e-10))
ssmin=log10(9.80665*rho_sat*(alpha_s2+n*4.4e-10))
lines(x=c(2.5,2.5),y=c(ssmax,ssmin),col="red")


##Ks and K0 from Rosetta (using grain fractions)
rosetta=read.table("data_rosetta_best.txt",sep="\t",header=T,skip=1)
rosetta["Ks_ms"]=10^rosetta$Ks/100/24/60/60
rosetta["K0_ms"]=10^rosetta$Ko/100/24/60/60

lines(x=rep(1.5,nrow(rosetta)),y=log10(rosetta$Ks_ms),col="blue")
lines(x=rep(1.6,nrow(rosetta)),y=log10(rosetta$K0_ms),col="green")
ksmax=max(rosetta$Ks_ms)
ksmin=min(rosetta$Ks_ms)

d0min=ksmin/(10^ssmax)
d0max=ksmax/(10^ssmin)
lines(x=c(3.5,3.5),y=c(log10(d0min),log10(d0max)),col="green")

##plot best
lines(x=c(0.8,1.2),y=c(log10(best$ks),log10(best$ks)),col="red")
lines(x=c(1.8,2.2),y=c(log10(best$ss),log10(best$ss)),col="red")
lines(x=c(2.8,3.2),y=c(log10(best$d0),log10(best$d0)),col="red")



##plot best raster
ks=corelList[corelList$cor==max(corelList$cor),]$ks
ss=corelList[corelList$cor==max(corelList$cor),]$ss

##initial conditions
##initial depth of water table
initFit=lm(suction~depthm,data=TDRdata)

##depth of water table
d=-coef(initFit)[1]/coef(initFit)[2]

##slope angle (to radian)
slope=31.3*pi/180

##time
time=c(0,420,820,1260,1680,2100,2520,2940,3360,3780,4200,4620,5040,5460,5880,6300,6720)
#time=c(0,0,0,420,820,1260,1680,2100,2520,2940,3360,3780,4200,4620,5040,5460,5880,6300,6720)

##precipitation (27.5 mm/h)
iz=c(0.0,0.0,0.0,0.0,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889,0.00000763889)

##number of time steps
tsteps=length(time)
nper=length(iz)

##coordiante transformation for slope-parallel ground water flow
#beta=cos(slope)^2
beta=coef(initFit)[2]

##beta-line (saturated)
psi0=(seq(zmin,zmax,zstep)-d)*beta
par(xaxs="i",yaxs="i")
#plot(psi0,seq(zmin,zmax,zstep),type="l",xlim=c(-40,0),ylim=c(zmax,0),ylab="Depth [m]",xlab="Pressure head [m]")
##beta-line (initial)
psisat=(seq(zmin,zmax,zstep))*beta
#lines(psisat,seq(zmin,zmax,zstep))
#abline(v=0)

##hydraulic diffusivity
d0=ks/ss

##correction of the original Iverson (2000) formula dm=4.0*d0*beta
##see Baum et al. 2010
dm=4.0*d0/cos(slope)^2

##all pwp time steps
pwpTime=data.frame()

# #own scripts ()
# cols=rev(topo.colors(tsteps))
# for (tstep in 1:(nper)){
#   tstar1=time[tstep]/(seq(zmin,zmax,zstep)^2/dm)
#   rstar1=(tstar1/pi)^0.5*exp(-1/tstar1)-erfc(1/(tstar1^0.5))
#   psistep1=beta*(1-d/seq(zmin,zmax,zstep))+iz[tstep]/ks*rstar1
#   psi1=seq(zmin,zmax,zstep)*psistep1
#   
#   ##limit is saturated beta-line
#   psi1[psi1>psisat]=psisat[psi1>psisat]
#   #print(psi1)
#   
#   pwpTime=rbind(pwpTime,psi1)
# }

##original/modified trigrs
cols=rev(topo.colors(tsteps))
tdata=data.frame(NA)
ptrans=0.0
for (tstep1 in 1:(nper+1)){
  t0=time[tstep1]
  zdata=data.frame()
  for (z in seq(zmin,zmax,zstep)){
    pzero=beta*(z-d)
    zstar=z**2/(4.*d0/cos(slope)^2)
    tstar=t0/zstar
    psi=0.0
    for (tstep2 in 1:nper){
      captstar1=time[tstep2]/zstar 
      tdif1=tstar-captstar1
      if(tdif1 > 0.0){
        rfa=((tdif1/pi)^0.5)*exp(-1./tdif1)-erfc(1./((tdif1)^0.5))
      }else{
        rfa=0.0
      }
      captstar2=time[tstep2+1]/zstar
      tdif2=tstar-captstar2
      if (tdif2 > 0.0){
        rfb=((tdif2/pi)^0.5)*exp(-1./tdif2)-erfc(1./((tdif2)^0.5))
      }else{
        rfb=0.0
      }
      #psi=psi+iz[tstep2]/ks*(rfa-rfb)
      psi=psi+iz[tstep2]/ks*(rfa-rfb)*z
    }
    pmax=z*beta
    if (abs(psi)>0.0){
      ptrans=psi
    }
    p=pzero+ptrans
    if (p>pmax){
      p=pmax
    }
    zdata=rbind(zdata,p)
  }
  #lines(zdata[,1],seq(zmin,zmax,zstep),col=cols[tstep1])
  tdata=cbind(tdata,zdata)
}
pwpTime=t(tdata[,c(-1,-length(time))])

data.c=pwpTime
##create color ramp
cols=colorRampPalette(brewer.pal(3,"RdBu"))(100)
##convert to matrix
data.m=as.matrix(t(data.c)[1:10,])
data.r=raster(data.m)

##stack rasters and compute correlation coefficient
raststack=stack(data.r,Suctionrast)
corel=layerStats(raststack,'pearson')
corel$'pearson correlation coefficient'[1,2]


##scale in regard to measurements
zMin=-30
zMax=-5
data.r[data.r>zMax]=zMax
data.r[data.r<zMin]=zMin

image(data.r)

##plot
colors=rev(colorRampPalette(brewer.pal(9,"RdBu"))(100))
par(xaxs="i",yaxs="i",mar=c(4,5,4,6))
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
axis(side=1,at=seq((1/(length(time)-1)/2),1-(1/(length(time)-1)/2),length.out=(length(time)-1)),labels=time[2:length(time)]/60)
axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
mtext(side=1,"Time [min]",line=2.5)
mtext(side=2,"Depth [m]",line=2.5,las=0)
mtext(side=4,line=5,"Pressure head [m]",las=0)
#plot(data.r,col=rev(colors),zlim=c(-0.5,-0.2),add=T)
plot(data.r,col=rev(colors),zlim=c(-30,-5),add=T)


##plot relative difference between model results and observations
par(mfrow=c(1,1))
##plot absolute change
par(xaxs="i",yaxs="i",mar=c(4,5,4,6))
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),axes=F,ylab="",xlab="")
axis(side=1,at=seq(1:ncol(scaleRatio))/10,labels=format(as.POSIXct(ert.time[,1],origin="1970-01-01"),format="%H:%M"))
axis(side=2,at=seq(0,1,0.2),labels=seq(1,0,-0.2),las=1)
mtext(side=1,"Time",line=2.5)
mtext(side=2,"Depth [m]",line=2.5,las=0)
#mtext(side=4,line=4,"Water content [%]",las=0)
#plot(RatioDatarast-data.r,col=rev(colors)[1:(length(colors)/(10/7))],add=T,zlim=c(-5,2))
diffrast=(RatioDatarast-data.r)/RatioDatarast
plot(diffrast,col=rev(colors),add=T,zlim=c(-0.5,0.5))

boxplot(diffrast@data@values,ylim=c(0,0.5))
```


###Difference of last measurement to measurement next day
```{r echo=F,message=F,warning=F}
nextday=as.Raster(readRAST6(rlist[1]))
lastmeasurement=as.Raster(readRAST6(rlist[length(rlist)]))
diffday=nextday-lastmeasurement
plot(log10(diffday))

plot(diffday/material.before)
```


```{r echo=F,message=F,warning=F}
##re-set root path
setwd(rootPath)
```